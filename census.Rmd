```{r include=FALSE, cache=FALSE}
set.seed(858)

options(
  digits = 3,
  dplyr.print_max = 6,
  dplyr.print_min = 6
)

knitr::opts_chunk$set(
  comment = "#>",
  fig.align = 'center',
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

image_dpi <- 125
```

# United States census

In this chapter, we'll use the tidycensus package. You'll need to install it if you haven't already.

```{r message=FALSE, warning=FALSE}
# install.packages("tidycensus")
library(tidycensus)
library(tidyverse)
```

## Census basics

The U.S. Census Bureau is a fantastic resource for data related to the U.S. population. As you saw in the [API Basics](http://dcl-wrangle.stanford.edu/api-basics.html) chapter, the Census Bureau makes a wide variety of APIs available. In this chapter, we'll focus on three: the decennial census, the American Community Survey, and the population estimates. 

As we mentioned previously, many R packages wrap commonly used APIs, making it easier for you to obtain data. In this chapter, we'll introduce one such package: [tidycensus](https://walkerke.github.io/tidycensus/). We'll show you how to use tidycensus to obtain data from the decennial census and American Community Survey. Then, we'll go into more detail about working directly with the Census Bureau APIs.

First, we'll give a bit of background about three U.S. Census data sources: the decennial census, the American Community Survey, and the population estimates. 

### Decennial census

When most people think of the U.S. Census, they're thinking about the decennial census. The Census Bureau conducts the decennial census every ten years (starting in 1790), with the goal of determining the number of people living in the United States. Because many features of the U.S. government, including the number of representatives awarded to each state, depend on accurate population counts, the decennial census is required by the Constitution. 

For the decennial census, the Census Bureau tries to survey every household in the U.S. in an attempt to count every U.S. resident. The population estimates that come from the decennial census are therefore the most definitive that you can find. However, decennial census data come out only every ten years, so can be out-of-date. The decennial census survey also only asks a few questions, primarily about household size, race, ethnicity.[^ U.S. Census Bureau. Questionnaires. https://www.census.gov/history/www/through_the_decades/questionnaires/] The American Community Survey provides more detailed and up-to-date data. 

### ACS

Between 1790 and 2000, decennial censuses included both a short form and a long form. Every household filled out the short form, but a sample also filled out the long form, which included additional questions. After 2000, the Census Bureau turned the long form into the American Community Survey (ACS), and began administering the ACS every year. 

The ACS, unlike the decennial census, is a sample. Every year, the ACS surveys a representative sample consisting of 3.5 million households. The Census Bureau then uses this sample to provide estimates for the entire U.S. population.[^ U.S. Census Bureau. American Community Survey: Information Guide. https://www.census.gov/content/dam/Census/programs-surveys/acs/about/ACS_Information_Guide.pdf]

The ACS calculates these estimates over two time periods: 1 year and 5 years. The 1-year estimates are the most current, but have larger margins of error due to their smaller sample size. Most of the time, you'll use the 5-year estimates. They don't have the granularity of the 1-year estimates, but are more reliable because of their larger sample sizes, particularly for smaller geographic units.

### Population estimates

The third data source we'll discuss comes from the Census Bureau's [Population Estimates Program (PEP)](https://www.census.gov/programs-surveys/popest.html). The decennial census publishes the definitive population of the United States every ten years. However, if you want to know the population of a U.S. geographic area between decennial census years, you'll need to use the [Population Estimates APIs](https://www.census.gov/data/developers/data-sets/popest-popproj/popest.html). 

The ACS also includes population estimates, but the estimation techniques used for the Population Estimates Program are more accurate.

### Choosing data

The first step to working with U.S. Census data is to decide which data source to use. Here's a quick guide:

__ACS__ 

Most of the time, you'll want the ACS. The ACS includes many different variables on social, economic, housing, and demographic aspects. 

You'll typically want the 5-year ACS, unless you're looking at a large or rapidly changing geographic area or need yearly data.

__Decennial census__

Use the decennial census if you want definitive population data, don't need that many variables, and don't mind that the data is only available every 10 years. 

__Population estimates__

Use data from the Population Estimates Program if you want accurate population data for a non-decennial census year (i.e., a year not divisible by 10).

## tidycensus

The [tidycensus package](https://walkerke.github.io/tidycensus/) wraps several U.S. Census Bureau APIs, allowing you to access decennial census and ACS data through R functions. 

Before you use tidycensus for the first time, you'll need to obtain a Census Bureau API key. You can request one [here](https://api.census.gov/data/key_signup.html). You'll receive an email with your key. Copy your key to the clipboard, then navigate back to RStudio. Run the following line to open your .Renviron:

```{r eval=FALSE}
usethis::edit_r_environ()
```

Then, add the following line, replacing `YOUR_API_KEY` with the key sent to you by the Census Bureau.

```{r eval=FALSE}
CENSUS_API_KEY='YOUR API KEY`
```

Restart R (_Ctrl/Cmd_ + _F10_) for the changes to take effect. 

From now on, you won't need to worry about a key. Your key will stay in your .Renviron across R sessions.

### Specify a dataset

We'll show you how to use the tidycensus package to access two Census APIs: the decennial census and the ACS. Before you start using tidycensus, you'll need to make two decide which dataset and year to use.

__Dataset__

See our discussion in [Choosing data](http://dcl-wrangle.stanford.edu/census.html#choosing-data) for the trade-off between the decennial census, ACS, and the different ACS estimates. 

For many tidycensus functions, you specify the different surveys in the following way:

* `"acs5"`: 5-year ACS
* `"acs1"`: 1-year ACS
* `"sf1"`: Decennial census

_sf_ stands for _Summary File_. Summary File 1 (`"sf1"`) corresponds to the short form described earlier, while Summary File 3 (`"sf3"`) corresponds to the long form. As explained earlier, the ACS took the place of the long form in 2001, so `"sf3"` is only available for censuses from 2000 or earlier.

__Year__

You'll also need to decide on a year. For the decennial censuses, `year` will just be the year of the decennial census. Remember that the decennial census occurs in years ending in 0. The tidycensus package can access the 1990, 2000, and 2010 decennial censuses.

For ACS data, the `year` argument of tidycensus functions refers to the end-year of the sample period. For example, if you want to use a 5-year ACS that ended in 2017, set `year = 2017`. As of January 2020, tidycensus supports the end-years 2010 through 2017. 

### Find variables

```{r echo=FALSE}
all_vars_decennial <- 
  load_variables(year = 2010, dataset = "sf1")

all_vars_acs5 <- 
  load_variables(year = 2017, dataset = "acs5")
```

Data from both the ACS and decennial census capture many variables. The 2010 decennial census includes `r format(nrow(all_vars_decennial), big.mark = ",")`, while the 2017 5-year ACS includes `r format(nrow(all_vars_acs5), big.mark = ",")`!

A code, like `H001001` or `P011014`, identifies each of these variables. To use tidycensus, you'll need to determine the codes of your variables of interest. We'll use the function `tidycensus::load_variables()` to find ACS or decennial census variables and their accompanying codes. `load_variables()` returns a tibble of all variable codes from a given dataset, alongside brief descriptions. 

If we wanted to look at the variables for the 2017 5-year ACS, we'd use

```{r eval=FALSE}
all_vars_acs5 <- 
  load_variables(year = 2017, dataset = "acs5")

all_vars_acs5
```
```{r echo=FALSE}
all_vars_acs5 %>% view()
```

`name` is the variable code. `label` is a description of the variable. `concept` is a broader categorization. 

Let's take a closer look at just one concept: sex by age.

```{r}
all_vars_acs5 %>% 
  filter(concept == "SEX BY AGE")
```

`r nrow(all_vars_acs5 %>% filter(concept == "SEX BY AGE"))` belong to the "SEX BY AGE" concept. Each row refers to a variable under that concept. 

This way of thinking about variables can be a bit confusing at first. Here, the `Estimate!!Total` variable captures the number of people for whom sex by age data is available. `Estimate!!Total!!Male` captures the total number of males, while `Estimate!!Total!!Male!!Under 5 years` captures the total number of males under 5 years old. 

```{r echo=FALSE}
knitr::include_graphics(
  "images/googlesheets/census/variable-graph.png", dpi = image_dpi
)
```

This is a bit more intuitive for concepts like `"SEX BY AGE (ASIAN ALONE)"`.

```{r}
all_vars_acs5 %>% 
  filter(concept == "SEX BY AGE (ASIAN ALONE)")
```

Here, `Estimate!!Total` represents the total number of Asian U.S. residents for whom sex/age data is relevant. 

```{r echo=FALSE}
knitr::include_graphics("images/googlesheets/census/acs-variables.png", dpi = image_dpi)
```


Most concepts have a `Estimate!!Total` variable, or something similar. If you want to calculate a proportion, such as the proportion of males, use the `Estimate!!Total` as the denominator. Sometimes, `Estimate!!Total` will not be the same as the overall total because the variable in question is not relevant or available for everyone. 

To find the variables you want, pipe the result of `load_variables()` into `view()`.

```{r eval=FALSE}
all_vars_acs5 %>% 
  view()
```

Then, use _Ctrl/Cmd_ + _F_ to search for variables with a given a keyword (e.g., "income"). Once you've found the variables you want, copy their codes (the `name` variable), and store them in a named vector.

```{r}
vars_acs5 <-
  c(
    median_income = "B06011_001",
    median_rent = "B25064_001"
  )
```

If we wanted to get variables from, say the 2010 decennial census, we'd use 

```{r eval=FALSE}
load_variables(year = 2010, dataset = "sf1") %>% 
  view()
```

The [documentation](https://www.census.gov/programs-surveys/acs/technical-documentation/code-lists.2018.html) for the ACS is helpful if you need additional information about ACS variables.

### Get data

tidycensus includes two functions for obtaining data from the Census Bureau: `get_acs()` and `get_decennial()`. 

At minimum, you should supply `get_acs()` and `get_decennial()` with three variables:

* `geography`
* `variables`
* `year`

`geography` controls the geographic level of the data returned. The tidycensus website includes a helpful [table of all available geographics](https://walkerke.github.io/tidycensus/articles/basic-usage.html#geography-in-tidycensus). Common values are "state" and "county". 

Supply `variables` with a vector of variable codes. Earlier, we stored the codes of some variables in the vector `vars_acs5`.

```{r}
vars_acs5
```

For `get_acs()`, `year` indicates the year that the ACS estimates _end_. If you want ACS estimates from 2012-2017, set `year = 2017`. By default, `get_acs()` uses the 5-year estimates. You can use other estimates by specifying `survey`.

```{r}
df_acs <-
  get_acs(
    geography = "state", 
    variables = vars_acs5, 
    year = 2017
  )

df_acs
```

`get_acs()` will return the estimate and margin of error (`moe`) for each variable. Because the ACS values are estimates, the Census Bureau calculates a margin of error for most variables. 

Note that the data isn't tidy, and we'll need to `pivot_wider()`.  

```{r}
df_acs %>% 
  pivot_wider(
    names_from = variable, 
    values_from = c(estimate, moe)
  )
```

`get_decennial()` works similarly. First, we'll find the variables with `load_variables()` and store several in a vector. 

```{r eval=FALSE}
load_variables(year = 2010, dataset = "sf1") %>% 
  view()
```

```{r}
vars_decennial <-
  c(
    pop_urban = "H002002",
    pop_rural = "H002005"
  )
```

Then, we'll use `get_decennial()` to access the data. This time, we'll get the data at the county level. Here, `year` is the year of the decennial census.

```{r}
df_decennial <-
  get_decennial(
    geography = "county", 
    variables = vars_decennial, 
    year = 2010
  )

df_decennial
```

Again, we need to `pivot_wider()`.

```{r}
df_decennial %>% 
  pivot_wider(names_from = variable, values_from = value)
```

Now, you can use your data however you wish. Note that, if you're interested in geospatial aspects of ACS or decennial census data, we recommend using our [ussf package](https://github.com/dcl-docs/ussf) for boundaries. 

```{r}
# remotes::install_github("dcl-docs/ussf")
library(ussf)
```

You can join your ACS or decennial census data with the result of `ussf::boundaries()`, using `GEOID` as a unique identifier. 

```{r}
df_acs %>% 
  left_join(
    boundaries(geography = "state") %>% select(GEOID, geometry), 
    by = "GEOID"
  )
```

