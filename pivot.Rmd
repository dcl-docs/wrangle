
# Pivot

## Basics

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r include=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)

eagle_nests <- 
  here::here("data/eagles/eagle_nests.rds") %>% 
  read_rds()
  
eagle_nests_tidy <- 
  here::here("data/eagles/eagle_nests_tidy.rds") %>% 
  read_rds()

eagle_nests_tidy_se <- 
  here::here("data/eagles/eagle_nests_tidy_ci.rds") %>% 
  read_rds()

eagle_pairs <-
  here::here("data/eagles/eagle_pairs.rds") %>% 
  read_rds()

acs <- 
  here::here("data/acs/acs_2012_2017.rds") %>% 
  read_rds()

migration_2017 <-
  here::here("data/migration/migration_2017.rds") %>% 
  read_rds()
```

Most of the data you'll encounter won't be tidy, and it will be your job to figure out how to make it tidy. In this chapter, you'll learn about two of the most important tidying tools: `pivot_longer()` and `pivot_wider()`. 

First, recall the characteristics of tidy data:

* Each value has its own cell.
* Each variable has its own column.
* Each observation has its own row.

```{r echo=FALSE}
knitr::include_graphics("images/pivot/tidy_elements.png", dpi = image_dpi)
```

Non-tidy data will not fulfill one or more of these characteristics.

### Longer

`eagle_nests` contains data on the number of [bald eagle nesting](https://www.flickr.com/photos/usfwsmidwest/16759298633/in/photolist-rwXMAH-bXW4Cm-28DuSx6-9PDwbH-eZx3or-bqZTS8-eZFq8y-9PDw8Z-eZu4QB-NoLDSB-bqZaqg-8RQQYM-eZFqQq-eZu4pV-VLBNvb-WshJpu-VXydWp-VLBKbq-WR8GDg-cDxjcE-bpEQe4-eZu41z-zbmBDJ-br1g6e-eZJpSu-eZx3aB-eZu3Yz-9PDwez-ayvEXy-QbaNpg-9LeFY4-eZx3s6-FS2b8D-vnh2u9-KiS4LA-8aBLgF-8RVSg3-8RSKFi-8RVSgU-qFccg6-9PDwde-eZJqg9-eZu3X6-bpEQiH-Ec2vTb-MxKio7-91FpA3-9PDwhH-91FojJ-91FoB9) sites across multiple regions and years.

```{r}
# Source: US Fish and Wildlife Service
eagle_nests
```

The data isn't tidy. Each value has its own cell and each observation has its own row, but each variable does not have its own column. In the following steps, we'll show you how to tidy `eagle_nests` using `pivot_longer()`. 

__Step 1:__ Identify the variables.

There are three variables in this dataset:

* `region`: The US region where the nests are located.
* `year`: The year the nests were found. 
* `num_nests`: The number of nests found. 

Only one of these (`region`) is currently a column in `eagle_nests`.

__Step 2:__ Identify the columns that need tidying.

We need to tidy the columns currently storing values of `year`: `2007` and `2009`. The `cols` argument controls which columns `pivot_longer()` tidies. 

```{r eval=FALSE}
eagle_nests %>% 
  pivot_longer(
    cols = c(`2007`, `2009`),
    
    
  )
```

You can specify these columns in the same ways that you can specify columns inside `select()`: by name, with `contains()`, `starts_with()`, etc. Here, we have to wrap `2007` and `2009` in backticks (``) because they start with numbers.

__Step 3__ Name the column that will store the values from the column names.

Currently, values representing year are stored in the column names `2007` and `2009`.

```{r echo=FALSE}
knitr::include_graphics("images/pivot/longer_names.png", dpi = image_dpi)
```

We want these column names to become the values of a new column called `year`. `pivot_longer()`'s `names_to` argument controls the name of this new column. The argument is called `names_to` because you're specifying which column to move the column __names__ to. 

```{r eval=FALSE}
eagle_nests %>% 
  pivot_longer(
    cols = c(`2007`, `2009`),
    names_to = "year",
    
  )
```

This will create a new column called `year` and fill it with the column names `2007` and `2009`. Because we specifying two columns in `cols`, we will get two values of `year` for each region. 

```{r echo=FALSE}
knitr::include_graphics("images/pivot/longer_1.png", dpi = image_dpi)
```

Note that `"year"` has to be in quotes. You're not identifying an existing column, you're providing a string. 

__Step 4__ Name the column that will store the column values.

Now, we need to tell `pivot_longer()` what to do with the values previously stored in `2007` and `2009`. 

```{r echo=FALSE}
knitr::include_graphics("images/pivot/longer_values.png", dpi = image_dpi)
```

`pivot_longer()`'s `values_to` argument controls the name of the column that will store these values. In `eagle_nests`, these values represent the number of nests. 

```{r eval=FALSE}
eagle_nests %>% 
  pivot_longer(cols = c(`2007`, `2009`), 
    names_to = "year", 
    values_to = "num_nests"
  )
```

`pivot_longer()` will now move the values from `2007` and `2009` to a column called `num_nests`.

```{r echo=FALSE}
knitr::include_graphics("images/pivot/longer_2.png", dpi = image_dpi)
```

Here's the function call again with the results.

```{r}
eagle_nests %>% 
  pivot_longer(
    cols = c(`2007`, `2009`), 
    names_to = "year", 
    values_to = "num_nests"
  )
```

The data is now tidy! `pivot_longer()` has many optional arguments, but `cols`, `names_to`, and `values_to` will cover most of your use-cases. The _Missing values_ and _Advanced_ sections covers some more specialized uses of `pivot_longer()`. 

Here's another eagle-related example. `eagle_pairs` contains data on the number of observed bald eagle breeding pairs across years and states. 

```{r}
eagle_pairs
```

Again, the date isn't tidy because values (the years) are contained in the column names. We need to tidy all the year columns (`1997` through `2006`), moving the column names to a column named `"year"` and the column values to a column named `"num_nests"`.  

Here's the full call to `pivot_longer()`:

```{r}
eagle_pairs %>% 
  pivot_longer(
    cols = -starts_with("state"), 
    names_to = "year",
    values_to = "num_pairs"
  )
```

### Wider

`pivot_wider()` is the reverse of `pivot_longers()`. `pivot_longer()` moves data from column names to cell values, while `pivot_wider()` pulls data from cell values into column names, creating a wider tibble.

`pivot_longer()` is generally more useful for tidying than `pivot_wider()`. Often, you'll actually use `pivot_wider()` to non-tidy data because the non-tidy format is more convenient for some task you want to do (e.g., creating a visualization).

We'll explain `pivot_wider()` by using it to turn the tidied `eagle_nests` back into its original form. Here's the tidied version:

```{r}
eagle_nests_tidy
```

__Step 1__ Identify the column whose values will supply the column names.

We want the values from `year` to supply the new column names. 

```{r echo=FALSE}
knitr::include_graphics("images/pivot/wider_names.png", dpi = image_dpi)
```

We specify `year` to `pivot_wider()`'s `names_from` argument. 

```{r eval=FALSE}
eagle_nests_tidy %>% 
  pivot_wider(names_from = year,                          )
```

Notice that `year` is unquoted, unlike `pivot_longer()'`s `names_to` argument, because we're referencing a column that exists in `eagle_nests_tidy`. 

__Step 2__ Identify the column whose values will supply the column values.

Now, we need to identify the column that will supply the values of `2007` and `2009`. In `eagle_nests_tidy`, that's `num_nests`.

```{r echo=FALSE}
knitr::include_graphics("images/pivot/wider_values.png", dpi = image_dpi)
```

We specify `num_nests` as the `values_from` argument.

```{r}
eagle_nests_tidy %>% 
  pivot_wider(names_from = year, values_from = num_nests)
```

Again, supply the name of the column unquoted. 

We're done! The tibble is now transformed back into its original form. 

Let's look at an example of a tibble that actually does need `pivot_wider()` to be tidy. `acs` contains data from the 2012 and 2017 American Community Surveys, obtained through the tidycensus package. 

```{r}
acs
```

`variable` and `estimate` are not really variables (if you see a variable named `variable` it's a good sign you need `pivot_wider()`). There are three distinct values in `variable`:

```{r}
acs %>% 
  distinct(variable)
```

Each of these values is actually a variable whose values are currently stored in `estimate`. To pivot, we'll set `names_from` to `variable` and `values_from` to `estimate`. 

```{r}
acs %>% 
  pivot_wider(names_from = variable, values_from = estimate)
```

We've been naming the arguments to `pivot_longer()` and `pivot_wider()` because it makes it easier to understand what's happening. It's also necessary to name `name_from` and `values_from` inside `pivot_wider()`, because it's first argument isn't actually `names_from`. It's another argument called `id_cols`. This means that if you don't name `names_from` and `values_from`, you'll get a strange error:

```{r error=TRUE}
eagle_nests_tidy %>% 
  pivot_wider(year, num_nests)
```

`pivot_wider()` thinks you're trying to supply `variable` to `id_cols`. We'll talk more about what `id_cols` actually does in the _Advanced_ section. For now, it's enough to know that you should name `names_from` and `values_from` to avoid the error. 

### Missing values

`migration_2017` shows the number of migrants from an origin country to a `dest` country in 2017.  

```{r}
migration_2017
```

Again, the data isn't tidy. `Afghanistan`, `Canada`, etc. are values of a variable, not variables themselves. We can use `pivot_longer()` to tidy the data.

```{r}
migration_2017 %>% 
  pivot_longer(cols = -dest, names_to = "origin", values_to = "migrants")
```

There are a lot of `NA`s in the data. However, they don't actually represent missing values. Someone didn't forget to measure the number of people who migrated from Afghanistan to Albania---no one migrated from Afghanistan to Albania in 2017. It doesn't really make sense to include these rows in our new, tidied dataset. We can use `values_drop_na` to exclude these rows.

```{r}
migration_2017 %>% 
  pivot_longer(
    cols = -dest, 
    names_to = "origin", 
    values_to = "migrants", 
    values_drop_na = TRUE
  ) 
```

When you use `values_drop_na = TRUE` in `pivot_longer()`, you're turning _explicit_ missing values into _implicit_ missing values. This is usually only a good idea if the `NA`s were in the non-tidy data only for a structural reason, like in `migration_2017`. 

```{r echo=FALSE}
knitr::include_graphics("images/pivot/missing_values.png", dpi = image_dpi)
```

`eagle_pairs`'s `NA`s aren't structual, and represent actual missing data. There were probably some number of paired Alabamian eagles in 2001, but the data isn't there. 

```{r}
eagle_pairs
```

If we used `values_drop_na = TRUE` when we pivoted `eagle_pairs`, we would turn all these explicit missing values implicit. 

## Advanced

So what does `id_cols` actually do? `id_cols` allows you to specify the columns that uniquely identify your observations. It's default value is all columns except the ones you are pivoting, so when we pivot `eagle_nests_tidy`, `id_cols` defaults to just `region`.

```{r}
eagle_nests_tidy %>% 
  pivot_wider(names_from = year, values_from = num_nests)
```

When we pivot `acs`, `id_cols` defaults to `geoid`, `name`, and `year`. 

```{r}
acs %>% 
  pivot_wider(names_from = variable, values_from = estimate)
```

Let's look at a situation in which you do need to use `id_cols`. `eagle_nests_tidy_se` includes another variable: `se`, which indicates the standard error for `num_nests`. However, `se` is only available for `2009`.

```{r}
eagle_nests_tidy_se
```

If we `pivot_wider()` just as we did before, we won't get the result that we want.

```{r}
eagle_nests_tidy_se %>% 
  pivot_wider(names_from = year, values_from = num_nests)
```

`pivot_wider()` thinks each `region`-`se` combination uniquely identifies observations, and so creates one row for each combination. We actually want `pivot_wider()` to just ignore `se`, because we want a single row for each region. We could accomplish this by using `select()` to get rid of `se` before pivoting. 

```{r}
eagle_nests_tidy_se %>% 
  select(-se) %>% 
  pivot_wider(names_from = year, values_from = num_nests)
```

Or, we can set `id_cols` to `region`. 

```{r}
eagle_nests_tidy_se %>% 
  pivot_wider(id_cols = region, names_from = year, values_from = num_nests)
```


[^1]: Tidy Data (vignette). https://tidyr.tidyverse.org/articles/tidy-data.html.
